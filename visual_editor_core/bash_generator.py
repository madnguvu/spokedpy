"""
Bash Code Generator from Universal IR.

This module generates Bash shell scripts from Universal Intermediate Representation.
"""

from typing import List, Dict, Any, Optional
from .universal_ir import (
    UniversalProject, UniversalModule, UniversalFunction, UniversalClass,
    UniversalVariable, Parameter, TypeSignature, DataType, LanguageMapping
)


class BashGenerator:
    """Generates Bash scripts from Universal IR."""
    
    def __init__(self):
        self.mapping = LanguageMapping("universal", "bash")
        self.indent_level = 0
        self.indent_size = 4
    
    def generate_module(self, module: UniversalModule) -> str:
        """Generate Bash code for a Universal Module."""
        lines = []
        
        # Shebang
        shebang = getattr(module, 'bash_shebang', None) or '/bin/bash'
        lines.append(f"#!{shebang}")
        lines.append("")
        
        # Script header comment
        lines.append(f"# {module.name}.sh")
        lines.append("# Generated by VPyD")
        lines.append("")
        
        # Strict mode
        lines.append("set -euo pipefail")
        lines.append("")
        
        # Source/import statements from module.imports (populated by parser / ledger)
        from .import_translator import translate_imports
        translated = translate_imports(module.imports, 'bash')
        sourced = []
        for imp in translated:
            stripped = imp.strip()
            if stripped and stripped not in sourced:
                sourced.append(stripped)
                lines.append(stripped)
        if sourced:
            lines.append("")
        
        # Generate constants/variables
        constants = [v for v in module.variables if v.is_constant]
        variables = [v for v in module.variables if not v.is_constant]
        
        if constants:
            lines.append("# Constants")
            for var in constants:
                lines.append(f"readonly {var.name}={self._format_value(var.value)}")
            lines.append("")
        
        if variables:
            lines.append("# Variables")
            for var in variables:
                lines.append(f"{var.name}={self._format_value(var.value)}")
            lines.append("")
        
        # Generate functions
        for func in module.functions:
            func_code = self._generate_function(func)
            lines.extend(func_code)
            lines.append("")
        
        # Main entry point
        if module.functions:
            lines.append("# Main entry point")
            lines.append('if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then')
            lines.append("    main \"$@\"")
            lines.append("fi")
        
        while lines and lines[-1] == "":
            lines.pop()
        
        return "\n".join(lines)
    
    def generate_project(self, project: UniversalProject) -> Dict[str, str]:
        """Generate Bash code for an entire project."""
        files = {}
        
        for module in project.modules:
            filename = f"{module.name}.sh"
            files[filename] = self.generate_module(module)
        
        return files
    
    def _indent(self, text: str = "") -> str:
        """Return properly indented text."""
        return " " * (self.indent_level * self.indent_size) + text
    
    def _format_value(self, value: Any) -> str:
        """Format value for Bash assignment."""
        if value is None:
            return '""'
        
        value_str = str(value)
        
        # Already quoted
        if (value_str.startswith('"') and value_str.endswith('"')) or \
           (value_str.startswith("'") and value_str.endswith("'")):
            return value_str
        
        # Quote if contains spaces or special chars
        if ' ' in value_str or any(c in value_str for c in '$`!'):
            return f'"{value_str}"'
        
        return value_str
    
    def _generate_function(self, func: UniversalFunction) -> List[str]:
        """Generate Bash function."""
        lines = []
        
        lines.append(f"{func.name}() {{")
        self.indent_level += 1
        
        # Generate parameter assignments
        for i, param in enumerate(func.parameters, 1):
            if param.name != 'args':
                lines.append(self._indent(f'local {param.name}="${{{i}:-}}"'))
        
        if func.parameters:
            lines.append("")
        
        lines.append(self._indent("# TODO: Implement"))
        
        # Check return type
        if func.return_type.base_type == DataType.INTEGER:
            lines.append(self._indent("return 0"))
        elif func.return_type.base_type != DataType.VOID:
            lines.append(self._indent('echo ""'))
        
        self.indent_level -= 1
        lines.append("}")
        
        return lines
    
    def _generate_if_statement(self, condition: str, body: List[str]) -> List[str]:
        """Generate if statement."""
        lines = []
        
        lines.append(self._indent(f"if [[ {condition} ]]; then"))
        self.indent_level += 1
        
        for line in body:
            lines.append(self._indent(line))
        
        self.indent_level -= 1
        lines.append(self._indent("fi"))
        
        return lines
    
    def _generate_for_loop(self, var: str, items: str, body: List[str]) -> List[str]:
        """Generate for loop."""
        lines = []
        
        lines.append(self._indent(f"for {var} in {items}; do"))
        self.indent_level += 1
        
        for line in body:
            lines.append(self._indent(line))
        
        self.indent_level -= 1
        lines.append(self._indent("done"))
        
        return lines
    
    def _generate_while_loop(self, condition: str, body: List[str]) -> List[str]:
        """Generate while loop."""
        lines = []
        
        lines.append(self._indent(f"while [[ {condition} ]]; do"))
        self.indent_level += 1
        
        for line in body:
            lines.append(self._indent(line))
        
        self.indent_level -= 1
        lines.append(self._indent("done"))
        
        return lines
    
    def _generate_case_statement(self, expr: str, cases: Dict[str, List[str]]) -> List[str]:
        """Generate case statement."""
        lines = []
        
        lines.append(self._indent(f"case {expr} in"))
        self.indent_level += 1
        
        for pattern, body in cases.items():
            lines.append(self._indent(f"{pattern})"))
            self.indent_level += 1
            for line in body:
                lines.append(self._indent(line))
            lines.append(self._indent(";;"))
            self.indent_level -= 1
        
        self.indent_level -= 1
        lines.append(self._indent("esac"))
        
        return lines
